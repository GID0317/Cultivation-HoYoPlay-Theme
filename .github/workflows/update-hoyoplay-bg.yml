name: Update HoYoPlay Backgrounds

on:
  schedule:
    - cron: '0 3 * * *'    # daily at 03:00 UTC
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  update-backgrounds:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create scripts folder
        run: mkdir -p .github/scripts

      - name: Install ImageMagick (for color extraction)
        run: sudo apt-get update && sudo apt-get install -y imagemagick

      - name: Write updater script
        run: |
          cat > .github/scripts/update-hoyoplay-bg.js <<'EOF'
          const fs = require('fs');
          const path = require('path');

          (async () => {
            try {
              const API = 'https://sg-hyp-api.hoyoverse.com/hyp/hyp-connect/api/getAllGameBasicInfo?launcher_id=VYTpXlbWo8&language=en-us&game_id=gopR6Cufr3';
              const outDir = path.join(process.cwd(), 'Background');
              if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

              console.log('Fetching API...');
              const res = await fetch(API, { headers: { 'User-Agent': 'github-action' } });
              if (!res.ok) throw new Error('API fetch failed ' + res.status);
              const j = await res.json();
              const list = j?.data?.game_info_list || [];
              if (!list.length) throw new Error('no game_info_list');
              const backgrounds = list[0].backgrounds || [];
              const urls = backgrounds.map(b => (b && b.background && b.background.url) || b?.url || '').filter(Boolean);
              const videoUrls = backgrounds.map(b => (b && b.video && b.video.url) || '').slice(0,3);
              const themeOverlayUrls = backgrounds.map(b => (b && b.theme && b.theme.url) || '').slice(0,3);
              const linkUrls = backgrounds.map(b => (b && b.link && b.link.url) || '').slice(0,3);
              const linkHoverUrls = backgrounds.map(b => (b && b.link_hover && b.link_hover.url) || '').slice(0,3);

              // Keep strict positions: only write image2 if a second url exists, and same for image3
              const first = urls[0] || '';
              const second = urls[1] || '';
              const third  = urls[2] || '';

              if (!first) throw new Error('no background urls found');

              // Also extract icon from the primary background entry (if present)
              const primary = backgrounds[0] || {};
              const iconUrl = (primary.icon && primary.icon.url) || '';
              const iconHoverUrl = (primary.icon && primary.icon.hover_url) || '';

              async function downloadTo(url, outPath) {
                console.log('Downloading', url);
                const r = await fetch(url, { headers: { 'User-Agent': 'github-action' } });
                if (!r.ok) throw new Error('download failed ' + r.status);
                const buf = Buffer.from(await r.arrayBuffer());
                fs.writeFileSync(outPath, buf);
                console.log('Saved', outPath);
              }

              function removeIfExists(outPath) {
                try {
                  if (fs.existsSync(outPath)) {
                    fs.unlinkSync(outPath);
                    console.log('Removed', outPath);
                  }
                } catch (e) {
                  console.warn('Failed to remove', outPath, e.message);
                }
              }

              const img1Path = path.join(outDir, 'image1.webp');
              const img2Path = path.join(outDir, 'image2.webp');
              const img3Path = path.join(outDir, 'image3.webp');

              if (first) {
                try { await downloadTo(first, img1Path); } catch (e) { console.warn('image1 download failed', e.message); removeIfExists(img1Path); }
              } else {
                removeIfExists(img1Path);
              }

              if (second) {
                try { await downloadTo(second, img2Path); } catch (e) { console.warn('image2 download failed', e.message); removeIfExists(img2Path); }
              } else {
                removeIfExists(img2Path);
              }

              if (third) {
                try { await downloadTo(third, img3Path); } catch (e) { console.warn('image3 download failed', e.message); removeIfExists(img3Path); }
              } else {
                removeIfExists(img3Path);
              }

              // Download per-circle video/overlay assets if available
              const videoPaths = [
                path.join(outDir, 'video1.webm'),
                path.join(outDir, 'video2.webm'),
                path.join(outDir, 'video3.webm')
              ];
              const overlayPaths = [
                path.join(outDir, 'overlay1.webp'),
                path.join(outDir, 'overlay2.webp'),
                path.join(outDir, 'overlay3.webp')
              ];
              const iconPath = path.join(outDir, 'icon.png');
              const iconHoverPath = path.join(outDir, 'icon-hover.png');
              const linkPaths = [
                path.join(outDir, 'link1.png'),
                path.join(outDir, 'link2.png'),
                path.join(outDir, 'link3.png')
              ];
              const linkHoverPaths = [
                path.join(outDir, 'link-hover1.png'),
                path.join(outDir, 'link-hover2.png'),
                path.join(outDir, 'link-hover3.png')
              ];
              // Loop each circle (1..3)
              for (let i = 0; i < 3; i++) {
                const vUrl = videoUrls[i];
                const oUrl = themeOverlayUrls[i];
                const vPath = videoPaths[i];
                const oPath = overlayPaths[i];
                const lUrl = linkUrls[i];
                const lhUrl = linkHoverUrls[i];
                if (vUrl) {
                  try { await downloadTo(vUrl, vPath); } catch(e) { console.warn(`video${i+1} download failed`, e.message); removeIfExists(vPath); }
                } else {
                  removeIfExists(vPath);
                }
                if (oUrl) {
                  try { await downloadTo(oUrl, oPath); } catch(e) { console.warn(`overlay${i+1} download failed`, e.message); removeIfExists(oPath); }
                } else {
                  removeIfExists(oPath);
                }
                if (lUrl) {
                  try { await downloadTo(lUrl, linkPaths[i]); } catch(e) { console.warn(`link${i+1} download failed`, e.message); removeIfExists(linkPaths[i]); }
                } else {
                  removeIfExists(linkPaths[i]);
                }
                if (lhUrl) {
                  try { await downloadTo(lhUrl, linkHoverPaths[i]); } catch(e) { console.warn(`link-hover${i+1} download failed`, e.message); removeIfExists(linkHoverPaths[i]); }
                } else {
                  removeIfExists(linkHoverPaths[i]);
                }
              }
              if (iconUrl) {
                try { await downloadTo(iconUrl, iconPath); } catch(e) { console.warn('icon download failed', e.message); removeIfExists(iconPath); }
              } else {
                removeIfExists(iconPath);
              }
              if (iconHoverUrl) {
                try { await downloadTo(iconHoverUrl, iconHoverPath); } catch(e) { console.warn('icon-hover download failed', e.message); removeIfExists(iconHoverPath); }
              } else {
                removeIfExists(iconHoverPath);
              }

              // Compute dominant colors from link/link-hover images using ImageMagick
              function getHexFromImage(imgPath) {
                try {
                  const { execSync } = require('child_process');
                  // Average the image to 1x1 then read that pixel in hex (RRGGBB)
                  const cmd = `convert "${imgPath}" -resize 1x1! -format "%[hex:u.p{0,0}]" info:`;
                  const out = String(execSync(cmd)).trim();
                  if (/^[0-9A-Fa-f]{6}$/.test(out)) return '#' + out.toUpperCase();
                } catch (e) {
                  console.warn('convert failed for', imgPath, e.message);
                }
                return '';
              }

              const colors = { circles: [] };
              for (let i = 0; i < 3; i++) {
                const linkP = linkPaths[i];
                const linkHoverP = linkHoverPaths[i];
                const c = {
                  link: fs.existsSync(linkP) ? getHexFromImage(linkP) : '',
                  hover: fs.existsSync(linkHoverP) ? getHexFromImage(linkHoverP) : ''
                };
                // Fallbacks: if hover missing, use link; if link missing, use hover
                if (!c.link && c.hover) c.link = c.hover;
                if (!c.hover && c.link) c.hover = c.link;
                // If still empty, default to white to match requested fallback
                if (!c.link) c.link = '#FFFFFF';
                if (!c.hover) c.hover = c.link;
                colors.circles.push(c);
              }
              const colorsJsonPath = path.join(outDir, 'circle-colors.json');
              fs.writeFileSync(colorsJsonPath, JSON.stringify(colors, null, 2));

              // Also emit 1x1 PNG swatches (color1/2/3.png) for CSP-safe client reads
              try {
                const { execSync } = require('child_process');
                for (let i = 0; i < 3; i++) {
                  const hex = colors.circles[i]?.link || '#FFFFFF';
                  const outP = path.join(outDir, `color${i+1}.png`);
                  // Create a 1x1 image filled with the hex color
                  execSync(`convert -size 1x1 xc:${hex} "${outP}"`);
                }
              } catch (e) {
                console.warn('Failed to create color swatch images', e.message);
              }

              // commit & push changes
              const execSync = require('child_process').execSync;
              execSync('git config user.name "github-actions[bot]"');
              execSync('git config user.email "41898282+github-actions[bot]@users.noreply.github.com"');
              // Stage all changes in Background (including deletions)
              execSync('git add -A Background');
              try { execSync('git commit -m "Auto-update HoYoPlay assets (images 1..3, videos/overlays 1..3, link/link-hover 1..3, colors json)"'); } catch(e) { console.log('No changes to commit'); }
              execSync('git push');
              console.log('Done');
            } catch (e) {
              console.error(e);
              process.exit(1);
            }
          })();
          EOF

      - name: Run updater
        env:
          NODE_OPTIONS: --unhandled-rejections=strict
        run: node .github/scripts/update-hoyoplay-bg.js
