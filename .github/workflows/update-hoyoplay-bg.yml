name: Update HoYoPlay Backgrounds

on:
  schedule:
    - cron: '0 3 * * *'    # daily at 03:00 UTC
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  update-backgrounds:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create scripts folder
        run: mkdir -p .github/scripts

      - name: Write updater script
        run: |
          cat > .github/scripts/update-hoyoplay-bg.js <<'EOF'
          const fs = require('fs');
          const path = require('path');

          (async () => {
            try {
              const API = 'https://sg-hyp-api.hoyoverse.com/hyp/hyp-connect/api/getAllGameBasicInfo?launcher_id=VYTpXlbWo8&language=en-us&game_id=gopR6Cufr3';
              const outDir = path.join(process.cwd(), 'Background');
              if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

              console.log('Fetching API...');
              const res = await fetch(API, { headers: { 'User-Agent': 'github-action' } });
              if (!res.ok) throw new Error('API fetch failed ' + res.status);
              const j = await res.json();
              const list = j?.data?.game_info_list || [];
              if (!list.length) throw new Error('no game_info_list');
              const backgrounds = list[0].backgrounds || [];
              const urls = backgrounds.map(b => (b && b.background && b.background.url) || b?.url || '').filter(Boolean);
              const videoUrls = backgrounds.map(b => (b && b.video && b.video.url) || '').slice(0,3);
              const themeOverlayUrls = backgrounds.map(b => (b && b.theme && b.theme.url) || '').slice(0,3);

              // Keep strict positions: only write image2 if a second url exists, and same for image3
              const first = urls[0] || '';
              const second = urls[1] || '';
              const third  = urls[2] || '';

              if (!first) throw new Error('no background urls found');

              // Also extract icon from the primary background entry (if present)
              const primary = backgrounds[0] || {};
              const iconUrl = (primary.icon && primary.icon.url) || '';
              const iconHoverUrl = (primary.icon && primary.icon.hover_url) || '';

              async function downloadTo(url, outPath) {
                console.log('Downloading', url);
                const r = await fetch(url, { headers: { 'User-Agent': 'github-action' } });
                if (!r.ok) throw new Error('download failed ' + r.status);
                const buf = Buffer.from(await r.arrayBuffer());
                fs.writeFileSync(outPath, buf);
                console.log('Saved', outPath);
              }

              function removeIfExists(outPath) {
                try {
                  if (fs.existsSync(outPath)) {
                    fs.unlinkSync(outPath);
                    console.log('Removed', outPath);
                  }
                } catch (e) {
                  console.warn('Failed to remove', outPath, e.message);
                }
              }

              const img1Path = path.join(outDir, 'image1.webp');
              const img2Path = path.join(outDir, 'image2.webp');
              const img3Path = path.join(outDir, 'image3.webp');

              if (first) {
                try { await downloadTo(first, img1Path); } catch (e) { console.warn('image1 download failed', e.message); removeIfExists(img1Path); }
              } else {
                removeIfExists(img1Path);
              }

              if (second) {
                try { await downloadTo(second, img2Path); } catch (e) { console.warn('image2 download failed', e.message); removeIfExists(img2Path); }
              } else {
                removeIfExists(img2Path);
              }

              if (third) {
                try { await downloadTo(third, img3Path); } catch (e) { console.warn('image3 download failed', e.message); removeIfExists(img3Path); }
              } else {
                removeIfExists(img3Path);
              }

              // Download per-circle video/overlay assets if available
              const videoPaths = [
                path.join(outDir, 'video1.webm'),
                path.join(outDir, 'video2.webm'),
                path.join(outDir, 'video3.webm')
              ];
              const overlayPaths = [
                path.join(outDir, 'overlay1.webp'),
                path.join(outDir, 'overlay2.webp'),
                path.join(outDir, 'overlay3.webp')
              ];
              const iconPath = path.join(outDir, 'icon.png');
              const iconHoverPath = path.join(outDir, 'icon-hover.png');
              // Loop each circle (1..3)
              for (let i = 0; i < 3; i++) {
                const vUrl = videoUrls[i];
                const oUrl = themeOverlayUrls[i];
                const vPath = videoPaths[i];
                const oPath = overlayPaths[i];
                if (vUrl) {
                  try { await downloadTo(vUrl, vPath); } catch(e) { console.warn(`video${i+1} download failed`, e.message); removeIfExists(vPath); }
                } else {
                  removeIfExists(vPath);
                }
                if (oUrl) {
                  try { await downloadTo(oUrl, oPath); } catch(e) { console.warn(`overlay${i+1} download failed`, e.message); removeIfExists(oPath); }
                } else {
                  removeIfExists(oPath);
                }
              }
              if (iconUrl) {
                try { await downloadTo(iconUrl, iconPath); } catch(e) { console.warn('icon download failed', e.message); removeIfExists(iconPath); }
              } else {
                removeIfExists(iconPath);
              }
              if (iconHoverUrl) {
                try { await downloadTo(iconHoverUrl, iconHoverPath); } catch(e) { console.warn('icon-hover download failed', e.message); removeIfExists(iconHoverPath); }
              } else {
                removeIfExists(iconHoverPath);
              }

              // commit & push changes
              const execSync = require('child_process').execSync;
              execSync('git config user.name "github-actions[bot]"');
              execSync('git config user.email "41898282+github-actions[bot]@users.noreply.github.com"');
              // Stage all changes in Background (including deletions)
              execSync('git add -A Background');
              try { execSync('git commit -m "Auto-update HoYoPlay backgrounds + media (images 1/2/3 + videos/overlays 1..3 + icon)"'); } catch(e) { console.log('No changes to commit'); }
              execSync('git push');
              console.log('Done');
            } catch (e) {
              console.error(e);
              process.exit(1);
            }
          })();
          EOF

      - name: Run updater
        env:
          NODE_OPTIONS: --unhandled-rejections=strict
        run: node .github/scripts/update-hoyoplay-bg.js
